# 알고리즘 시간 복잡도 분석

### 1. 두 알고리즘의 속도를 비교하는 방법 : 같은 입력에 대한 두 프로그램 처리 속도 측정

But 프로그램 처리 속도 측정이 부적합한 이유 : 속도에 영향을 줄 수 있는 요소가 많다.
(하드웨어, 사용 프로그래밍 언어 등등) 

실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못한다.

### 2. 알고리즘 수행 시간은 반복문이 수행되는 횟수로 측정한다. (수행 시간에 따른 알고리즘 효율성 분석)


# 선형 시간 알고리즘

### 1. 이동 평균 : 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준
이동 평균의 이론상 매 지점마다 평균을 계산하기 때문에 많은 반복문이 수행된다. – 수행 시간을 줄이기 위해 중복된 계산을 없앤다. (이전 수치와 현재 수치 계산에서 어떤 점이 중복되는지 확인한다)

(선형시간 – 입력된 길이 n에 대한 실행 시간)

### 2. 선형 이하 시간
많은 값들이 순서대로 나열된 경우 그 중간값을 통해 입력 수를 줄인다. (이로 인해 선형 시간보다 더 짧은 수행 시간을 가질 수 있다) – 중간값을 이용해 수행 시간을 선형 시간 이하로 낮추는 방법을 이진 탐색이라고 부른다.


# 지수 시간 알고리즘

### 1. 다항 시간 알고리즘
반본묵의 수행 횟수를 다항식으로 표현현할 수 있는 알고리즘을 다항 시간 알고리즘이라고 한다. (뿌리내리기를 통해 목록 순서대로 갈림길을 만든다) 이러한 문제를 해결하는 알고리즘으로 재귀 호출이 가장 많이 사용된다.

### 2. 지수 시간 알고리즘
지수 시간 : 지수 함수에서 변수의 값이 늘어날때마다 프로그램 수행 시간이 기하급수적으로 늘어난다. 이 알고리즘들은 지수 시간에 동작한다고 말한다. 현재 지수 함수에서 지수 시간보다 빠른 알고리즘을 찾기 어렵다. (입력 수)

### 3. 소인수 분해의 수행 시간
소인수 분해를 수행하는 시간은 해당 값에 종류에 따라 달라진다. 제일 많은 수행 시간이 소요되는 것은 소수를 소인수 분해할 경우이다. 나누어 떨어지는 수가 없어 반복문을 많이 수행하게 된다. (입력 값)



# 시간 복잡도

시간 복잡도가 높다는 것은 입력의 크기가 증가할 때 알고리즘 수행 시간이 더 빠르게 증가한다는 의미이다.
(입력값과 수행시간에 대한 그래프는 직선이 아니다!)

입력의 크기는 수행 시간을 결정하는 무조건적인 척도는 아니다. 
(때로는 위치나 다른 요소에 따라 알고리즘 수행 시간이 달라진다)

### 1. 점근적 시간 표기: O표기법
: 전체 수행 시간에 가장 영향을 주는 항만 남긴 채 나머지를 다 버리는 표기법(계수 또한 버림)
N^2 이  주요항인 경우 O(N^2)이라고 표시한다.
(두개의 항의 영향이 동일한 경우 둘다 표시한다)
O 표기법은 각 알고리즘의 수행 시간을 간단히 나타낼 수 있는 표기법일 뿐 최악의 수행시간을 분석하는데 관련이 있지 않다.

### * O 표기법 연습

(1) 반복문의 횟수를 알아낸다. 입력값 N에 따라 반복문 횟수는 어떤지 N에 대한 다항식으로 표현한다.

(2) 최고차항을 제외한 나머지 항을 버리고 O 표기법으로 표기한다.

### 2. 분할 상환 분석
부분으로 보는 것이 아니라 전체 작업의 시간으로 분석하는 방법
-> 이를 통해 시간이 오래 걸려 실행하지 못할 것이라고 여겼던 작업이 시간 안에 돌아간다는 것을 이해할 수 있음

# 수행 시간 어림짐작하기

### 1. 주먹구구 법칙
프로그래밍 대회에서는 프로그램 수행 시간을 기준으로 한다. 이에 가장 영향을 주는 요소는 입력의 최대 크기와 시간 복잡도이다.
O 표기법에 따라 수행 횟수와 항을 비교하여 알고리즘 효율을 판단하는 법칙을 말한다.

### 2. 주먹구구 법칙을 맹신하면 안되는 이유

(1) 시간 복잡도가 실제 수행 속도를 반영하지 못한 경우
: 시간 복잡도는 최고차항을 뽑은 어디까지나 예측값이다.

(2) 반복문의 내부가 복잡한 경우
: 반복문 내부가 단순하지 않은 경우(파일 입출력, 실수 연산) 더 오래 걸릴 수 있다.

(3) 메모리 사용 패턴이 복잡한 경우
: 캐시 메모리는 연속해서 사용하는 값에 대해 이미 저장된 자료를 사용한다. 
이런 차이는 시간 복잡도와 무관하게 프로그램 수행 속도를 더 빠르게 해준다

(4) 언어와 컴파일러에 따라
: 최적화나 성능이 언어나 컴파일러마다 다르다.


# 계산 복잡도 클래스 ( 공부 중점 )

시간복잡도는 알고리즘의 특성이다. 알고리즘은 문제마다 여러 개 있을 수 있으므로 이를 혼합하여 생각해야 한다.
계산 복잡도는 문제에 대해 알고리즘을 기준으로 분류하며 그 특성을 연구하는 학문이다.

(1) 문제의 특성 공부하기 : 주어진 많은 문제들은 특성에 따라 분류할 수 있다. 
분류된 문제들은 최적화된 비슷한 알고리즘으로 풀이된다.

(2) 난이도의 함정 : 어려운 문제의 기준을 정하고 그것보다 어려운 문제를 “어려운 문제”라고 정의하자. 
우리가 알고 있는 가장 빠른 알고리즘이 가장 빠르다고 생각하지 말자.

(3) NP문제란? : 답이 주어졌을 때 이것이 정답인지 시간 내에 확인할 수 있는 문제. 
이 문제를 어려운 문제의 기준으로 삼자.



