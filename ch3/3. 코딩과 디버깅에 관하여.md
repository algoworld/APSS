# 03. 코딩과 디버깅에 관하여 by suzy  
:코딩과 디버깅에 관한 노하우 + 프로그래밍 대회에서 자주 하는 실수들   

-----
### 코딩의 중요성  
-빨리 코드를 작성하는 것보다 읽기 쉬운 코드를 작성하라   

### 좋은 코드를 짜기 위한 원칙  
➀간결한 코드를 작성하기  
:코드가 짧을수록 오타나 단순한 버그가 생길 우려가 적어지고 디버깅이 쉽다.  
ex) 전역변수의 사용 , c/c++매크로 사용 ->프로그래밍 대회에서만 사용하는 예  
    
➁적극적으로 코드 재사용하기  
: 코드를 모듈화하는 것   
-같은 코드가 반복되면 함수나 클래스로 분리해 재사용하는 것   
    
➂표준 라이브러리 공부하기   
-언어의 문자열, 동적배열, 스택 , 큐 , 리스트, 사전 등의 자료구조, 정렬을 알아두어야 한다.   
    
➃항상 같은 형태로 프로그램을 작성하기  

➄일관적이고 명료한 명명법 사용하기  
:모호하지 않은 변수명과 함수명을 사용하는 버릇을 가지고 사용하는 언어의 표준 라이브러리에서 사용하는 명명규약을 익혀라.

➅모든 자료를 정규화해서 저장하기  
-ex)시간, 기약분수, 각도

➆코드와 데이터를 분리하기  

### 자주 하는 실수  
➀산술 오버플로
  
➁배열 범위 밖 원소에 접근 
  
➂일관되지 않은 범위 표현 방식 사용하기
-프로그래밍 언어는 주로 반 열린구간을 사용한다. 반 열린 구간은 첫 번째 값은 집합 안에 포함하고, 다른 하나는 집합 안에 포함하지 않는다.
  
➃Off-by-one오류
: 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들 
-반복문에서  < > <= >= 연산자를 혼동하여 원소를 하나 더 적게, 혹은 많이 순회하는 경우 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 흔하게 발생
  
➄컴파일러가 잡아주지 못하는 상수 오타
-상수를 잘못입력해서 오답 처리되는 경우가 많다.
  
➅스택 오버 플로
-프로그램 실행 중 call stack이 오버플로해서 프로그램이 강제 종료되는 것은 많이 하는 실수
  
➆다차원 배열 인덱스 순서 바꿔쓰기
-ex) 동적계획법을 위한 메모이제이션 패턴 사용시, 특정 배열에 접근하는 위치를 하나로 통일하자 
  
➇잘못된 비교 함수 작성
  
➈최소, 최대 예외 잘못 다루기
  
➉연산자 우선순위 잘못쓰기
ex)if(b&1) == 0 
-얼핏보면 b의 푀하 비트가 0일 때 참처럼 보이지만 비트단위 AND연산자인 &의 우선순위는 비교연산자인 ==보다 낮아 조건문은 항상 거짓이 된다
-연산자의 우선순위를 잘 기억해두고, 헷갈릴 경우에는 괄호로 적절하게 감ᄊᆞ자
  
⑪너무 느린 입출력 방식 선택 
-자신이 사용하는 언어에서 어떤 입출력 방식이 지원되는지 확인하고, 어느 쪽이  빠른지 미리 점검하자.
  
⑫변수 초기화 문제
-흔한 실수는 이전 입력에서 사용한 전역변수 값을 초기화 하지 않고 그대로 사용하는 것 ->예방) 예제 입력 파일을 두 번 반복해 쓰는 것 
  
### 디버깅에 관하여
-눈으로 디버깅하는 것이 더  경우가 있다.
-재귀 호출이나 중복 반복문을 사용하는 복잡한 코드는 디버거로 디버깅하기에 적당하지 않다.
1) 작은 입력에 대해 제대로 실행 되나 확인하기 
2) 단정문(assertion)을 쓰기 : assertion이란 주어진 조건이 거짓 일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문. 주어진 조건이 참일 때는 무시되고, 거짓일 때만 오류
3)프로그램의 계산 중간 결과를 출력하기 : 프로그램이 실행되는 중간 과정을 출력하고 자신이 예상하는 바와 맞아 들어가는지 검사
  
###테스트에 관하여 
-제출 전에 예제 입력을 만들어 가능한 한 많이 프로그램을 테스트하는 것이 좋다. 
-주어진 예제 입력을 바꿔서 넣어 보거나 있을 수 있는 가장 작은 입력과 가장 큰 입력을 만들어서 넣어 보고 시간안에 실행되는지 답은 잘나오는지 테스트해 보는 것이 좋다. 
-scaffolding(스캐폴딩): 다른 코드를 개발 할 때 뼈대를 잡기 위해 임시로 사용하는 코드, 코드의 정당성을 확인하거나 반례를 찾을 때 유용 
  
###변수 범위의 이해
1) 산술 오버플로
: 어떤 식의 계산 값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우
   
2) 너무 큰 결과
-흔히 사용하는 32비트 자료형의 범위를 넘어가면 64비트 정수를 사용하거나 큰 정수 구현을 이용해야한다. 하지만 습관적으로 32비트 정수를 쓰는 실수가 흔하다.
-변수의 형태에 주의하는 습관을 들이자
  
3) 너무 큰 중간 값
: 프로그램의 출력 값이 범위는 작지만 중간 과정에서 MS 값을 일시적으로 계산해야하는 경우 
-계산의 중간 값이 너무 커서 오버플로욲가 날 수 있다.
  
4)　너무 큰 ‘무한대’값
-프로그램을 짜다보면 무한대에 해당하는 큰 값을 사용할 때가 있다. 
-무한대 값을 선택할 때는 무한 대 값들이 서로 더해지거나 곱해지는 경우가 없는 지 잘 살펴보고 오버플로가 나지 않을 크기의 값을 선택하는 것이 좋다. 
  
5) 오버플로 피해가기
-오버플로가 발생한다는 사실을 알았을 때 어떻게 고치면 오버플로를 막을 수 있을까? 
 =>➀더 큰 자료형을 쓰는 것 ➁연산의 순서를 바꾸는 것 
  
6) 자료형의 프로모션 
-프로모션: 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들은 같은 자료형으로 변환해서 사용하는 것 , 가끔 버그의 원인 
➀한 쪽은 정수형, 한 쪽은 실수형 => 정수형이 실수형으로 변환
➁양쪽 다 정수형이거나 양쪽 다 실수형일 경우 => 보다 넓은 범위를 갖는 자료형으로 변환
➂양쪽 다 int형보다 작은 정수형인 경우 => 양쪽 다 int 형으로 변환
➃부호 없는 정수형과 부호 있는 정수형이 섞여있는 경우 => 부호 없는 정수형으로 변환
-프로모션과 관련한 문제들은 대게 부호 있는 정수와 부호 없는 정수형이 섞였을 때 발생 
  
*실수자료형의 이해
1) 실수 연산의 어려움
  
2) 실수와 근사 값
:정수의 수식은 몇 번을 계산하더라도 같은 값이 반호나되지만, 실수의 계산에서는 같은 수식을 두 번 계산하더라도 어떤 순서로 계산하는지, 컴파일러 최적화는 켰는지, 심지어는 중간에 로그 메시지를 출력하는지 여부에 따라서 그 답이 달라질 수 있다. 컴퓨터가 사용하는 실수 표현 방식과 그 장단점을 이해해야 한다. 
  
3) IEEE 754표준
-특징)
➀이진수로 실수를 표기
➁부동 소수점 표기법 
➂무한대, 비 정규 수 등의 특수한 값 존재 
  
4) 실수의 이진법 표기
-소수점 및 I번째 자리의 크기는 
-이진수 표기로는, 소수점 밑 I번째 자리의 크기는 
  
5) 부동 소수점 표기
:어떤 형태의 숫자든지 소수점을 적절하게 옮겨서 소수점 위에 한 자리만 남도록 한 뒤, 최상위 비트에서부터 표현할 수 있는 만큼 표시하고 나머지는 반올림, 소수점을 몇 칸이나 옮겼는지 기록해 두면 원래 값을 재구성 할 수 있다.   
-고정소수점 방식보다 더 넓은 범위의 수를 표현할 수 있음   
ex) 11.625는 이진법으로 1011.101이다. 소수점을 왼쪽으로 세칸 옮기면 1.011101이 되고 이 수를 맨 앞에서부터 저장공간이 허락하는 만큼 저장한다. 
 이진법에서는 소수점 위에 있을 수 있는 유일한 숫자는 1이다. 따라서 1을 제외한 나머지를 저장하는 방식으로 1비트를 절약한다. 예를 들어, 5비트 만을 저장할 수 있다면 최상위 비트를 제외한 다음 비트인 01110을 저장한다.  
➊sign bit (부호 비트): 양수인지 음수인지 여부  
➋exponent (지수) : 소수점을 몇 칸 옮겼는가   
➌mantissa (가수) : 소수점을 옮긴 실수의 최상위 x비트   
-부동소수점 표기방식: 소수점을 움직이는 실수 표기법 <-> 고정 소수점 표기법   
-부호비트는 1비트라고 하고, 지수와 가수에는 각각 몇 비트를 써야 할까? 지수와 가수가 가지는 비중을 어떻게 조절하느냐에 따라 실수형이 표현 할 수 있는 숫자의 크기와 정확도가 결정된다.   
-IEEE754를 만든 사람들은 실수형에서 지수보다 가수에 훨씬 많은 비트수 부여, 지수는 소수점을 움직이는 횟수이기 때문에 지수가 상대적으로 작더라도 실생활에서 사용하는 거의 모든 숫자들을 표현할 수 있다.   
-정확도에 큰 의미가 없는 경우를 제외하면 32비트형은 아예 마음에서 지우고 64비트형 쓰기를 권장   

  
６） 실수 비교하기  
-컴퓨터는 실수를 근사적으로 표현한다.  
 ➀비교할 실수의 크기들에 비례한 오차 한도를 측정한다.  
 -같다고 판단해야 할 큰 값 두 개를 비교할 경우
 -다르게 판단해야 하는 작은 값 두 개를 비교하는 경우  ➁상대 오차를 이용한다.
- 비교하는 숫자들의 크기에 비례하여 오차를 정하는 방식을 사용해야 한다. 두 숫자의 크기에 비해 그 차이가 작다면 두 수가 같다. 
    
7) 대소 비교
    
8) 정확한 사칙연산
    
9) 코드의 수치적 안정성 파악하기 
-어떤 프로그램이 수치적으로 안정적이다: 프로그램의 실행 과정에서 발생하는 오차가 더 커지지 않는다. 
    
10) 실수 연산 아예 하지 않기
 ➀곱셈과 나눗셈의 순서를 바꾸기 
  ex) a/b*c를 계산해야되는데, 결과가 항상 정수라는 것을 알고 있다고 하자. 그러면 (a*c)/b 형태로 수식을 바꿈으로써 실수 연산을 쓰지 않고 결과를 계산할 수 있다. 
➁양변 제곱하기 
ex) 두 점 사이의 거리, 직접구하는 것보다 양변 제곱
➂실수좌표를 써야 하는 기하 문제에서 좌표계를 가로 세로로 정수 배 늘리면 정수만을 이용해 문제를 풀 수 있다. 
