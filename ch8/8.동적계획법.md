# 08. 동적 계획법
-----------------------
   
     
## *Dynamic programming
:두 번이상 반복 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘  
-분할 정복과 같은 접근방식을 의미하는데, 왜? 동적 계획법을 사용하는 알고리즘들 또한 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고 원래 문제에 대한 답을 계산해 내므로. 차이는 문제를 나누는 방식이다.
-동적계획법에서 어ᄄᅠᆫ 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에 문제의 답을 여러번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용 함으로서 속도를 높일 수 있다. 
-중복문제를 해결하기 위해 고안된 알고리즘 설계기법
-최적화문제를 연구하는 수학 이론에서 옴
-동적, 프로그래밍 단어와는 관련없음
-적절한 번역은 동적프로그래밍이 아니라 동적 계획법
-cache(캐시): 이미 계산한 값을 저장해 두는 메모리의 장소
-overlapping subprogram: 두 번이상 계산되는 부분 문제를 중복되는 부분문제라고 함
-가장 유명한 예) 이항계수 

## *메모이제이션(memoization)
: 함수의 결과를 저장하는 장소를 마련해두고, 한 번 계싼한 값을 저장해 뒀다 재활용하는 최적화 기법, 모든 부분문제가 한번씩만 계산된다고 보장할 수 있어 함수 호출 횟수 감소 
  
 ### ▶메모이제이션을 적용할 수 있는 경우)
 -참조적 투명성: 함수의 반환 값이 그 입력 값만으로 결정되는지의 여부
 -참조적 투명성 함수: 입력이 고정되어 있을 때 그 결과가 항상 같은 함수 
 -메모이제이션은 참조적 투명함수의 경우에만 적용할 수 있다. 입력이 같더라도 외부 요소에 따라 다른 값이 반환되면 캐싱이 불가하다
.   
 ### ▶메모이제이션 구현 패턴)
 -기저사례 먼저 처리
 -cache초기화
  
 ### ▶시간복잡도 분석)
 (존재하는 부분 문제의 수) x (한 부분 문제를 풀 때 필요한 반복문의 수행횟수) 
  
## *동적 계획법 레시피
➀주어진 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만들기
-완전탐색 알고리즘: 하나씩 만들어보면서 도달 할 수 있는지
➁중복된 부분 문제를 한 번만 계산하도록 메모이제이션 적용하기 
-다른 구현방법)
 반복적 동적 계획법 : 재귀 호출을 이용하지 않고도 동적 계획법 알고리즘 구현
  
## *최적 부분 구조
: 현재까지 어ᄄᅠᆫ 경로로 이 부분 문제에 도달했든지 남은 부분 문제는 항상 최적으로 풀어도 된다. 
-각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 조건이 성립한다. 
  
## *최적화 문제에서 동적 계획 레시피
➀모든 답을 만들어 본 후 완전 탐색 알고리즘을 설계
➁전체 답을 구하는 것이 아닌 앞으로 남은 선택들에 해당하는 부분 답만 반환하도록 부분 문제 정의를 바꾼다.
➂재귀 호출의 입력에 이전의 선택에 관련된 정보가 있다면 꼭 필요한 정보만 남기고 줄인다. 
➃입력이 배열이나 문자열인 경우 가능하다면 적절한 변환을 통해 메모이제이션 할 수 있도록 한다.
➄메모이제이션을 적용
  
*부분 문제의 개수가 너무 많으면 답이 항상 어떤 구조를 가질 것이라고 예측하고 강제하기
  
*한개의 구간에 대한 답을 찾기
➀주어진 구간을 어떤 수로 표현할지
➁결정한 수로 해당 구간을 표현했을 때 오차를 계산한다.
  
## 경우의 수 계산하기 레시피
➀모든 답을 직접 만들어서 세어보는 완전 탐색 알고리즘을 설계한다. 경우의 수를 제대로 세려면 재귀호출의 각 단계에서 고르는 선택지에 a,b속성이 성립해야함
 a) 모든 경우는 이 선택지들에 포함됨
 b) 어떤 경우도 두 개 이상의 선택지에 포함되지 않음
➁결정할 요소들에 대한 입력을 없애거나 변형하여 줄임
➂메모이제이션 적용
  
### *마르코프 연쇄
-유한 개의 상태가 있다
-매 시간마다 상태가 변경된다
-어떤 상태 a에서 다른 상태 b로 옮겨갈 확률은 현재 상태 a에만 좌우된다. a이전에 어느 상태에 있었는지, 현재 시간은 얼마인지는 영향을 주지 않는다.
