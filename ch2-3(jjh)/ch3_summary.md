# 코딩과 디버깅에 관하여
코딩은 매우 중요하다! 코딩에 가장 중요한 점은 반복적인 연습을 거쳐 자신의 코드 스타일을 간결하고 일관되게 다듬어야 한다는 점이다.

1. 좋은 코드를 짜기 위한 원칙

(1) 간결한 코드 작성하기 : 대표적인 예로 전역변수 사용이 있다. 전역변수는 적게 사용하는 것이 좋다. 
(2) 코드 재사용 : 만약 반복적인 코드를 사용해야 할 때 함수나 클래스로 분리하여 재사용하는 것이 좋다.
(3) 라이브러리 활용하기 : 각 언어마다 제공하는 라이브러리가 있다. 적극적으로 활용하자. 큐나 스택은 원리만 알면 될 뿐 실전에서 직접 구현할 필요는 없다.
(4) 항상 같은 형태로 프로그램 작성 : 자주 작성하는 알고리즘 코드는 항상 같은 형태로 작성한다.
(5) 명료한 명명법 : 중요한 부분이다. 변수의 이름을 정할 때 그 뜻을 어느정도 이해할 수 있게한다.
(6) 모든 자료를 정규화 해서 지정한다 : 여러가지 형태가 나올 경우를 여지에 두어 혼란스럽게 하지 않는다. 대표적인 예로 각도가 있다. (360도와 0도는 같은 의미이다. 한 의미로 통일시키자)
(7) 코드와 데이터를 분리한다 : 배열을 적극 활용한다. 코드와 데이터를 분리하면 프로그래머가 실수하지 않게 도와준다.

2. 자주하는 실수

(1) 산술 오버 플로우 : 배열 범위 밖의 원소에 접근할 때 주로 발생한다
(2) 일관되지 않은 범위 표현 방식 : 배열 [2,3,4….12]일 때 보통 범위를 [2,12]라고 표현하지만 프로그래밍 언어에서는 반 열린 구간을 사용한다. 즉 end 값에 가상의 값 1을 더하여 [2,13]이라고 표현한다. 
(3) 상수를 잘못 입력한 경우 : 변수 오타는 컴파일러에서 잡아주지만 상수 입력을 잘못한 경우 오답 처리가 된다. 이를 방지하기 위해 코드와 데이터를 분리하는 것이다.
(4) 스택 오버플로 : 클래스 인스턴스가 기본적으로 스택 메모리를 사용하기에 오버플로해서 프로그램을 강제로 종료하는 경우가 있다. 재귀 호출도 스택 오버플로의 원인이다.
(5) 다차원 배열 인덱스 : 2차원 이상 배열을 구현할 때 인덱스 값을 바꿔 쓰는 경우가 있다.
(6) 비교 함수 오류 : 언어마다 비교의 표준으로 삼는 부등호가 다르다. 
(7) 최소, 최대 예외 잘못 다루기 : 최소, 최대는 대부분이 적용되는 조건을 안 따르는 경우가 있다. 이럴 경우 특별하게 예외 처리를 해야 한다.
(8) 연산자 우선순위 잘못 쓰기 : 모든 연산자에는 우선 순위가 존재한다.
(9) 변수 초기화 문제 : c/c++의 경우 별도의 선언이 없다면 모든 변수는 기본값으로 초기화되는데 이는 에러가 발생하지 않지만 의도치 않은 결과값을 도출한다.

3. 디버깅과 테스팅
: 실무에서 디버거 도구는 오류를 적발하는데 좋은 도구지만 보통 코드가 짧은 프로그래밍 대회에서는 직접 눈으로 보는 경우가 더 효율적이다.

작은 입력에 제대로 실행? -> 조건문을 중간에 삽입(오류시 강제 종료) -> 프로그램 계산 중간 값을 출력한다(어느 부분이 오류인지 알아낸다)

(1) 스케폴딩을 활용하라 : 코드를 테스트 하기 위해 임시로 코드를 작성하라. 가장 큰 예시는 프로그래머가 일일이 입력값을 넣어주는 것이 아니라 반복문을 활용해 여러가지 결과값을 도출하자
(2) 산술 오버플로 : 대부분 프로그래밍 언어는 산술 오버플로에 대해서 별도의 경고를 해 주지 않는다. 항상 이 점을 염두에 두고 큰 결과가 예상되는 경우에는 64비트 이상의 자료형을 사용하는 경우가 좋다.
(3) 피연산자 프로모션 : 프로모션이란 이항 연산시 피연산자들의 자료형이 다르거나 범위가 작은 경우 자동으로 같은 자료형으로 변환하는 것을 말한다. 이는 편리한 도구지만 가끔 버그를 만들 수 있다. (각 언어마다 프로모션 조건이 어떻게 되는지를 살펴본다)
(4) 실수의 계산 : 실수는 무한의 영역에 가깝다. 컴퓨터가 실수를 이진법으로 어떻게 표현하는지 숙지하자. 실수 변수는 부호비트, 지수, 가수 이 세가지 정보를 저장한다. 
(5) 실수의 비교 : 실수는 항상 정확한 값이 아닌 근사값으로 저장되므로 정확한 비교가 어렵다. 이에 크기들에 비례한 오차 한도를 정해서 비교한다. 주어진 자리수 파악이 어렵다면 상대 오차를 이용한다. 
결론 : 실수 연산을 할때는 많은 경우의 수를 염두에 두어야 한다. 수치적으로 안정적이지 않기 때문에 가장 근사한 결과값 도출을 목표로 한다.

